# Release Automation Workflow
# Creates releases and changelogs

name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: true
      prerelease:
        description: 'Is this a pre-release?'
        required: false
        default: 'false'
        type: boolean

permissions:
  contents: write
  packages: write
  issues: write
  pull-requests: write

jobs:
  release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      changelog: ${{ steps.changelog.outputs.changelog }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine version
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION="${GITHUB_REF#refs/tags/}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Release version: $VERSION"

      - name: Generate changelog
        id: changelog
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const version = '${{ steps.version.outputs.version }}';
            
            // Get the previous tag
            const { data: tags } = await github.rest.repos.listTags({
              owner,
              repo,
              per_page: 10
            });
            
            const currentTagIndex = tags.findIndex(t => t.name === version);
            const previousTag = tags[currentTagIndex + 1]?.name || '';
            
            console.log(`Generating changelog from ${previousTag || 'beginning'} to ${version}`);
            
            // Get commits between tags
            let commits = [];
            if (previousTag) {
              const { data: comparison } = await github.rest.repos.compareCommits({
                owner,
                repo,
                base: previousTag,
                head: version
              });
              commits = comparison.commits;
            } else {
              const { data: allCommits } = await github.rest.repos.listCommits({
                owner,
                repo,
                per_page: 100
              });
              commits = allCommits;
            }
            
            // Categorize commits
            const categories = {
              'âœ¨ Features': [],
              'ðŸ› Bug Fixes': [],
              'ðŸ“š Documentation': [],
              'ðŸ”§ Maintenance': [],
              'â¬†ï¸ Dependencies': [],
              'ðŸ”’ Security': [],
              'ðŸŽ¨ Style': [],
              'â™»ï¸ Refactoring': [],
              'ðŸ§ª Tests': [],
              'ðŸš€ Performance': [],
              'ðŸ“¦ Other': []
            };
            
            for (const commit of commits) {
              const message = commit.commit.message.split('\n')[0];
              const sha = commit.sha.substring(0, 7);
              const author = commit.author?.login || commit.commit.author.name;
              const entry = `- ${message} (${sha}) @${author}`;
              
              if (message.startsWith('feat') || message.includes('feature')) {
                categories['âœ¨ Features'].push(entry);
              } else if (message.startsWith('fix') || message.includes('bug')) {
                categories['ðŸ› Bug Fixes'].push(entry);
              } else if (message.startsWith('docs')) {
                categories['ðŸ“š Documentation'].push(entry);
              } else if (message.startsWith('chore') || message.startsWith('build')) {
                categories['ðŸ”§ Maintenance'].push(entry);
              } else if (message.startsWith('deps') || message.includes('dependabot')) {
                categories['â¬†ï¸ Dependencies'].push(entry);
              } else if (message.startsWith('security') || message.includes('security')) {
                categories['ðŸ”’ Security'].push(entry);
              } else if (message.startsWith('style')) {
                categories['ðŸŽ¨ Style'].push(entry);
              } else if (message.startsWith('refactor')) {
                categories['â™»ï¸ Refactoring'].push(entry);
              } else if (message.startsWith('test')) {
                categories['ðŸ§ª Tests'].push(entry);
              } else if (message.startsWith('perf')) {
                categories['ðŸš€ Performance'].push(entry);
              } else {
                categories['ðŸ“¦ Other'].push(entry);
              }
            }
            
            // Build changelog
            let changelog = `## What's Changed\n\n`;
            
            for (const [category, items] of Object.entries(categories)) {
              if (items.length > 0) {
                changelog += `### ${category}\n\n`;
                changelog += items.join('\n') + '\n\n';
              }
            }
            
            // Add contributors
            const contributors = [...new Set(commits.map(c => c.author?.login).filter(Boolean))];
            if (contributors.length > 0) {
              changelog += `## Contributors\n\n`;
              changelog += contributors.map(c => `- @${c}`).join('\n') + '\n\n';
            }
            
            if (previousTag) {
              changelog += `**Full Changelog**: https://github.com/${owner}/${repo}/compare/${previousTag}...${version}`;
            }
            
            core.setOutput('changelog', changelog);
            return changelog;

      - name: Create Release
        uses: actions/github-script@v7
        env:
          CHANGELOG: ${{ steps.changelog.outputs.changelog }}
        with:
          script: |
            const { owner, repo } = context.repo;
            const version = '${{ steps.version.outputs.version }}';
            const changelog = process.env.CHANGELOG || '';
            const isPrerelease = version.includes('-') || 
                                version.includes('alpha') || 
                                version.includes('beta') || 
                                version.includes('rc') ||
                                '${{ github.event.inputs.prerelease }}' === 'true';
            
            await github.rest.repos.createRelease({
              owner,
              repo,
              tag_name: version,
              name: `Release ${version}`,
              body: changelog,
              draft: false,
              prerelease: isPrerelease,
              generate_release_notes: false
            });
            
            console.log(`Created release ${version}`);

  # Build and upload release assets
  build-assets:
    name: Build Release Assets
    runs-on: ubuntu-latest
    needs: release
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --ignore-scripts
        continue-on-error: true

      - name: Build
        run: npm run build --if-present
        continue-on-error: true
        env:
          NODE_ENV: production

      - name: Create archive
        run: |
          mkdir -p release
          if [ -d "dist" ]; then
            tar -czvf release/dist-${{ needs.release.outputs.version }}.tar.gz dist/
          fi
          if [ -d "build" ]; then
            tar -czvf release/build-${{ needs.release.outputs.version }}.tar.gz build/
          fi

      - name: Upload release assets
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { owner, repo } = context.repo;
            const version = '${{ needs.release.outputs.version }}';
            
            // Get the release
            const { data: release } = await github.rest.repos.getReleaseByTag({
              owner,
              repo,
              tag: version
            });
            
            // Upload assets
            const releaseDir = 'release';
            if (fs.existsSync(releaseDir)) {
              const files = fs.readdirSync(releaseDir);
              
              for (const file of files) {
                const filePath = path.join(releaseDir, file);
                const stats = fs.statSync(filePath);
                
                if (stats.isFile()) {
                  console.log(`Uploading ${file}...`);
                  
                  await github.rest.repos.uploadReleaseAsset({
                    owner,
                    repo,
                    release_id: release.id,
                    name: file,
                    data: fs.readFileSync(filePath)
                  });
                }
              }
            }

  # Notify about release
  notify:
    name: Notify Release
    runs-on: ubuntu-latest
    needs: [release, build-assets]
    steps:
      - name: Create announcement issue
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const version = '${{ needs.release.outputs.version }}';
            
            // Create a discussion or announcement (if discussions are enabled)
            console.log(`Release ${version} completed successfully!`);
            
            // You could also send notifications via:
            // - Slack webhook
            // - Discord webhook
            // - Email notification
            // - Twitter API
            // etc.
